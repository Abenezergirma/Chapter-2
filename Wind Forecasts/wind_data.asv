clear all; clc;
% define area
lower_left = [-96.84, 33.14];
upper_right = [-96.81,33.17];
num_points = 1000;
lons = linspace(lower_left(1), upper_right(1), round(sqrt(num_points)));
lats = linspace(lower_left(2), upper_right(2), round(sqrt(num_points)));

coordinates = generateCoordinates(lons, lats);
longitudes = coordinates(:,1);
latitudes = coordinates(:,2);

coefs_u = [ 0.00000000e+00  1.61094414e-10 -7.37058611e-03 -1.48809651e-06...
 -3.68089481e-13 -7.95141020e-06  2.10701150e-17  9.01146727e-10...
  1.59724993e-17  6.10108129e-10  7.28957673e-14  8.49416234e-19...
  7.23116917e-13  4.75030720e-19  1.14705027e-12];
intercept_u = 10.362042657397877;

coefs_v = [ 0.00000000e+00 -2.00488263e-10  8.08528198e-03 -7.92842850e-07...
  4.03295347e-13  3.32875723e-06 -1.06781708e-17 -7.96012216e-11...
 -1.33310503e-17 -4.23514366e-09  7.95707308e-14 -4.36936906e-19...
 -5.13247109e-14 -4.72047951e-19 -1.17203841e-12];
intercept_v = 3.69631689881155;
degree = 4;

center_lon = (-96.84 + -96.81) / 2;
center_lat = (33.14 + 33.17) / 2; 

[m_lat, m_lon] = latLonToMeters(latitudes, longitudes, center_lat, center_lon);

xs = linspace(-1396.37606554, 1396.37606554,1287);
ys = linspace(-1667.92389967, 1667.92389967,  1287);


[Us, Vs] = calculateWindComponents(coefs_u, intercept_u, coefs_v, intercept_v, m_lon, m_lat, degree);
[u,v] = calculateWindComponents(coefs_u, intercept_u, coefs_v, intercept_v, 1000, 1000, degree)


plotWindData(deg2rad(longitudes), deg2rad(latitudes), Us, Vs)

function [Us, Vs] = calculateWindComponents(coefs_u, intercept_u, coefs_v, intercept_v, xs, ys, degree)
    % Calculate wind components in MATLAB, correctly handling intercepts.

    % Ensure xs and ys are column vectors
    xs = xs(:);
    ys = ys(:);

    % Combine xs and ys into a single matrix of shape (n_samples, n_features)
    features = [xs, ys];

    % Generate polynomial features
    polyFeatures = generatePolynomialFeatures(features, degree);

    % Calculate the wind components by dot product, then add the intercept
    Us = polyFeatures * coefs_u' + intercept_u;
    Vs = polyFeatures * coefs_v' + intercept_v;
end

function polyFeatures = generatePolynomialFeatures(features, degree)
    % Manually generate polynomial features up to a specified degree for 2D features
    [n_samples, ~] = size(features);

    % Initialize a list to hold all feature combinations
    featureList = {ones(n_samples, 1)}; % Start with the bias (intercept) term

    % Generate feature combinations
    for d = 1:degree
        for i = 0:d
            j = d - i;
            newFeature = (features(:,1).^i) .* (features(:,2).^j);
            featureList{end+1} = newFeature;
        end
    end

    % Combine all features into a single matrix
    polyFeatures = horzcat(featureList{:});
end

function plotWindData(longitudes, latitudes, U_pred, V_pred)
longitudes = longitudes(:);
latitudes = latitudes(:);
U_pred = U_pred(:);
V_pred = V_pred(:);
% Calculate the magnitudes of original and predicted wind components
% Normalize U_pred and V_pred
norm_factor = sqrt(U_pred.^2 + V_pred.^2);
U_normalized = U_pred ./ norm_factor;
V_normalized = V_pred ./ norm_factor;

% Create a mesh grid for contour plots
[grid_x, grid_y] = meshgrid(linspace(min(longitudes), max(longitudes), 100), ...
    linspace(min(latitudes), max(latitudes), 100));

% Interpolate magnitudes onto the grid
grid_z_pred = griddata(longitudes, latitudes, norm_factor, grid_x, grid_y, 'linear');

% Plotting original wind field with contours
figure;

contourf(grid_x, grid_y, grid_z_pred', 15, 'LineStyle', 'none');
cbar = colorbar;
cbar.Label.String = 'Wind Speed (magnitude)'; % Corrected label setting
hold on;
quiver(longitudes, latitudes, U_normalized, V_normalized, 0.5, 'b');
title('Predicted Wind Field');
xlabel('Longitude');
ylabel('Latitude');
grid on;
end
function plotWindDataAnd(longitudes, latitudes, U_pred, V_pred, trajectory)
    longitudes = longitudes(:);
    latitudes = latitudes(:);
    U_pred = U_pred(:);
    V_pred = V_pred(:);
    % Calculate the magnitudes of original and predicted wind components
    % Normalize U_pred and V_pred
    norm_factor = sqrt(U_pred.^2 + V_pred.^2);
    U_normalized = U_pred ./ norm_factor;
    V_normalized = V_pred ./ norm_factor;
    
    % Create a mesh grid for contour plots
    [grid_x, grid_y] = meshgrid(linspace(min(longitudes), max(longitudes), 100), ...
        linspace(min(latitudes), max(latitudes), 100));
    
    % Interpolate magnitudes onto the grid
    grid_z_pred = griddata(longitudes, latitudes, norm_factor, grid_x, grid_y, 'linear');
    
    % Plotting original wind field with contours
    figure;
    
    contourf(grid_x, grid_y, grid_z_pred', 15, 'LineStyle', 'none');
    cbar = colorbar;
    cbar.Label.String = 'Wind Speed (magnitude)'; % Corrected label setting
    hold on;
    quiver(longitudes, latitudes, U_normalized, V_normalized, 0.5, 'b');
    
    % Plot the trajectory
    % Assuming the trajectory is an array with rows as [x, y] coordinates
    plot(trajectory(:,1), trajectory(:,2), 'r', 'LineWidth', 2);
    
    title('Predicted Wind Field');
    xlabel('Longitude');
    ylabel('Latitude');
    grid on;
end


function [m_lat, m_lon] = latLonToMeters(lat, lon, center_lat, center_lon)
    % Earth's radius in meters
    R = 6371000;
    
    % Convert latitude and longitude differences to radians
    delta_lat = (lat - center_lat) * pi / 180;
    delta_lon = (lon - center_lon) * pi / 180;
    
    % Approximate conversion to meters
    m_lat = delta_lat * R;
    m_lon = delta_lon * R * cos(center_lat * pi / 180);
end

function coordinates = generateCoordinates(lons, lats)
    % Initialize an empty array to hold the coordinate pairs
    coordinates = [];

    % Iterate through each lon and lat value to create [lon, lat] pairs
    for i = 1:length(lons)
        for j = 1:length(lats)
            % Append the [lon, lat] pair to the coordinates array
            coordinates = [coordinates; [lons(i), lats(j)]];
        end
    end
end




import os
import pickle
import numpy as np
import matplotlib.pyplot as plt
import time
from prog_algs.state_estimators import UnscentedKalmanFilter
from prog_algs.uncertain_data import MultivariateNormalDist
from prog_algs import predictors
from prog_algs.metrics import prob_success
from battery_electrochem_TarotT18 import BatteryElectroChemEOD as Battery

class BatteryPrognostics:
    """
    A class for battery prognostics using advanced algorithms and models.

    This class leverages the prog_algs library developed by NASA and the electrochemical model of the TartT18 battery
    to perform battery prognostics. It takes multiple inputs including future battery loading, the number of simulations
    for Monte Carlo-based prediction, battery end of discharge threshold (VEOD), and the chosen predictor method.

    Attributes:
        future_loading (numpy.ndarray): Future battery loading data generated by UAV simulation.
        num_simulations (int): Number of simulations for Monte Carlo-based prediction.
        VEOD (float): Battery end of discharge threshold.
        predictor_method (str): Chosen predictor method.

    Methods:
        initialize_battery: Initializes the battery model with measurement and process noises.
        run_estimator: Initializes an unscented Kalman Filter-based estimator.
        run_predictor: Executes the prognostics experiment using initialized battery and estimators.
        save_prognostics_output: Saves the output of the prognostics experiment as a .pkl file.
    """

    def __init__(self, current_data_file, num_simulations, sample_time, VEOD, predictor_method):
        """
        Initialize the BatteryPrognostics instance.

        Args:
            future_loading (numpy.ndarray): Future battery loading data generated by UAV simulation.
            num_simulations (int): Number of simulations for Monte Carlo-based prediction.
            VEOD (float): Battery end of discharge threshold.
            predictor_method (str): Chosen predictor method.
        """
        self.current_data_file = current_data_file
        self.num_simulations = num_simulations
        self.sample_time = sample_time
        self.VEOD = VEOD
        self.predictor_method = predictor_method
        self.loading = self.current_requirement()
        self.battery, self.initial_state = self.initialize_battery()
        self.experiment_index = None
  
    def current_requirement(self):
        # Code for current requirement collection here based on self.current_data_file
        # Return the loading data
        Iapp = self.current_data_file
        time = np.arange(0, len(Iapp) * self.sample_time, self.sample_time)
        time = np.round(time, 3)
        loading = dict(zip(time, Iapp))
        return loading
    
    def tarrot_loading(self, t, x={}):
        if t < (len(self.loading) * self.sample_time):
            Iapp = self.current_data_file #this may be changed to self.loading
            k = int(t*10)
            i = Iapp[k]
        else:
            i = 500
        return {"i": i}
    

    def initialize_battery(self):
        """
        Initialize the battery model with measurement and process noises.
        """
        # Return initialized battery and initial state
        
        # Add Process and Measurement noises
        R_vars = {"t": 12.2, "v": 15.46}
        battery = Battery(measurement_noise=R_vars)
        initial_state = battery.parameters["x0"]
        battery.parameters["VEOD"] = self.VEOD  # put the user defined VEOD here
        INITIAL_UNCERT = 30  # Uncertainty in initial state (%)
        
        # Construct covariance matrix (making sure each value is positive)
        cov = np.diag(
            [max(abs(INITIAL_UNCERT * value), 1e-3) for value in initial_state.values()]
        )
        initial_state = MultivariateNormalDist(
            initial_state.keys(), initial_state.values(), cov
        )
        return battery, initial_state

    def run_estimator(self):
        """
        Initialize an unscented Kalman Filter-based estimator.
        """
        # Return the filter
        
        print("\nPerforming State Estimation Step")
        filter = UnscentedKalmanFilter(self.battery, self.initial_state)

        # Step 2b: Print & Plot Prior State
        print("\nPrior State:", filter.x.mean)
        print("\tSOC: ", self.battery.event_state(filter.x.mean)["EOD"])
       
        # Step 2c: Perform state estimation step
        example_measurements = {"t": 292.2, "v": 25}
        
        print("Current of batt = ", self.tarrot_loading(self.sample_time))
        filter.estimate(self.sample_time, self.tarrot_loading(self.sample_time), example_measurements)
        return filter

    def run_predictor(self, filter):
        """
        Perform battery prognostics using initialized battery and estimators.
        """
        # Return mc_results
            # Step 3: Demonstrating Predictor
        print("\n\nPerforming Prediction Step")

        if self.predictor_method == "MC":
            # Step 3a: Setup Predictor
            mc = predictors.MonteCarlo(self.battery)
            # Step 3b: Perform a prediction
            NUM_SAMPLES = self.num_simulations
            STEP_SIZE = 2 * self.sample_time
            mc_results = mc.predict(
                filter.x, self.tarrot_loading, n_samples=NUM_SAMPLES, dt=STEP_SIZE,save_freq=1, events=['EOD']
            )

        elif self.predictor_method == "UT":
            STEP_SIZE = 2 * self.sample_time
            mc = predictors.UnscentedTransform(self.battery)
            mc_results = mc.predict(filter.x, self.tarrot_loading, dt=STEP_SIZE, save_freq=1, events=['EOD'])

        else:
            raise Exception("Unknown predictor algorithm")

        return mc_results

    def analyze_results(self, mc_results):
        # Code for analyzing results here based on mc_results
        # print("Im here")
        pass
    
    def save_prognostics_output(self,mc_results):
        """
        Save the output of the prognostics experiment as a .pkl file.

        Args:
            mc_results: Data containing the results of the prognostics experiment.
        """
        current_directory = os.path.dirname(os.path.abspath(__file__))  # Get the current directory of the script
        prog_results_file = os.path.join(current_directory, "..", "BatteryPrognosticsResults/Pickles/prog_results_{}.pkl".format(self.experiment_index))

        with open(prog_results_file, "wb") as output:
            pickle.dump(mc_results, output, pickle.HIGHEST_PROTOCOL)
        return 
        

    def main(self):
        start = time.perf_counter()

        filter = self.run_estimator()
        mc_results = self.run_predictor(filter)

        end = time.perf_counter()
        print("\tRuntime: {:4.2f}s".format(end - start))
        
        self.save_prognostics_output(mc_results)

        self.analyze_results(mc_results)

        print("ToE", mc_results.time_of_event.mean)


if __name__ == "__main__":
    current_data_file = "current_matlab_high_wind_3_.txt"
    num_simulations = 5
    sample_time = 0.1
    VEOD = 18
    predictor_method = "MC"

    app = BatteryPrognostics(
        current_data_file, num_simulations, sample_time, VEOD, predictor_method
    )
    app.main()
